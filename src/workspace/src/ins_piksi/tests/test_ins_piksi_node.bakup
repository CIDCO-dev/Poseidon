#include <ros/ros.h>
#include <ros/package.h>
#include <gtest/gtest.h>

#include <bitset>
#include <thread>

#include <fstream>
#include <fcntl.h>
#include <termios.h> // Contains POSIX terminal control definitions
#include <unistd.h>


TEST(PiksiTestSuite, testCaseCanReceiveData) {
	
	std::string serialPortPath = "/dev/ttyACM0";
	ROS_ERROR_STREAM("testing serial port over USB on path: " << serialPortPath );
	
	int serial_port = open(serialPortPath.c_str(), O_RDWR | O_NOCTTY);
	if(serial_port < 0) {
		ROS_ERROR_STREAM("Can't open path: " << serialPortPath );
	
	} else {
	
	struct termios tty;
	memset(&tty, 0, sizeof tty);
	
	if(tcgetattr(serial_port, &tty) != 0) {
		ROS_ERROR_STREAM("Error " << errno << " from tcsetattr: " << strerror(errno));
		close(serial_port);
	} else {
		//c_cflag
		tty.c_cflag &= ~PARENB; // Clear parity bit, disabling parity (most common)
		tty.c_cflag &= ~CSTOPB; // Clear stop field, only one stop bit used in communication (most common)
		tty.c_cflag |= CS8; // 8 bits per byte (most common)
		tty.c_cflag &= ~CRTSCTS; // Disable RTS/CTS hardware flow control (most common)
		tty.c_cflag |= CREAD | CLOCAL; // Turn on READ & ignore ctrl lines (CLOCAL = 1)
		
		//c_lflag
		tty.c_lflag &= ~ICANON;
		tty.c_lflag &= ~ECHO; // Disable echo
		tty.c_lflag &= ~ECHOE; // Disable erasure
		tty.c_lflag &= ~ECHONL; // Disable new-line echo
		tty.c_lflag &= ~ISIG; // Disable interpretation of INTR, QUIT and SUSP
		
		//c_iflag
		tty.c_iflag &= ~(IXON | IXOFF | IXANY); // Turn off s/w flow ctrl
		tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL); // Disable any special handling of received bytes
		
		//c_oflag
		tty.c_oflag &= ~OPOST; // Prevent special interpretation of output bytes (e.g. newline chars)
		tty.c_oflag &= ~ONLCR; // Prevent conversion of newline to carriage return/line feed
		
		//c_cc
		tty.c_cc[VTIME] = 10;    // Wait for up to 1s (10 deciseconds), returning as soon as any data is received.
		tty.c_cc[VMIN] = 0;
		
		//baudrate
		cfsetispeed(&tty, B115200);
		cfsetospeed(&tty, B115200);
		
		if (tcsetattr(serial_port, TCSANOW, &tty) != 0) {
			ROS_ERROR_STREAM("Error " << errno << " from tcsetattr: " << strerror(errno));
			close(serial_port);
		} else {
		
			close(serial_port);
		}
	}
	
	}
}


/*
TEST(PiksiTestSuite, testCaseCanReceiveDataLikeZedF9p) {

    int howManyDatagrams = 1000;

    //std::string logPath (argv[1]);
	std::string serialPortPath = "/dev/ttyACM0";

	int serial_port = open(serialPortPath.c_str(), O_RDWR | O_NOCTTY);

	struct termios tty;
    memset(&tty, 0, sizeof tty);

    if(tcgetattr(serial_port, &tty) != 0) {
  	ROS_ERROR_STREAM("Error1:");
        ROS_ERROR_STREAM("Error " << errno << " from tcsetattr: " << strerror(errno));
    }

    tty.c_cflag = CRTSCTS | CS8 | CLOCAL | CREAD;

    tty.c_lflag = 0;

    tty.c_iflag = IGNPAR;
    

    tty.c_oflag = 0;

    tty.c_cc[VTIME] = 0; // no inter-character timer
    tty.c_cc[VMIN] = 5; // blocking read until 1 char is received

    // Set in/out baud rate to be 115200
    cfsetispeed(&tty, B115200);
    cfsetospeed(&tty, B115200);

    if (tcsetattr(serial_port, TCSANOW, &tty) != 0) {
	ROS_ERROR_STREAM("Error2:");
        ROS_ERROR_STREAM("Error " << errno << " from tcsetattr: " << strerror(errno));
        //printf("Error %i from tcsetattr: %s\n", errno, strerror(errno));
    }


    char find_datagram_buf;


    bool lookingForFirstDatagram = true;
    int sizeCRC = 2;
    while(lookingForFirstDatagram) { //read serial port until found 0x55
        int n = read(serial_port, &find_datagram_buf, 1);
        if(find_datagram_buf == 0x55) {
            std::bitset<8> x(find_datagram_buf);
            ROS_ERROR_STREAM("Found first datagram: " << x);


            int sizePreambleFollowup = 5;  // 5 = 6-1, we already have th 0x55
            char first_datagram_preamble[sizePreambleFollowup];
            read(serial_port, &first_datagram_preamble, sizePreambleFollowup);
            if(false) {

            }



            int sizePayload = first_datagram_preamble[4];
            if(sizePayload < 0) {
           	ROS_ERROR_STREAM("Length of first datagram payload: " << sizePayload << " bytes.");
                continue;
            }

            char first_datagram_payloadBuffer[sizePayload];
            read(serial_port, &first_datagram_payloadBuffer, sizePayload);

            char first_datagram_CRC[sizeCRC];
            read(serial_port, &first_datagram_CRC, sizeCRC);

            //lookingForFirstDatagram = false;
            ROS_ERROR_STREAM("Sender: " << (int)first_datagram_preamble[2] << " " << (int)first_datagram_preamble[3]);
            ROS_ERROR_STREAM("Length of first datagram payload: " << sizePayload << " bytes.");
        } else {
            //ROS_ERROR_STREAM("No 0x55");
        }
    }

    std::ofstream file;
    std::string outputFilename = "test.sbp";
    file.open(outputFilename.c_str(),std::ios::app|std::ios::out|std::ios::binary);

    if(file) {
        int count = 0;
        while(count < howManyDatagrams) {


        }
    } else {
        ROS_ERROR_STREAM("Could not open file: " << outputFilename);
    }

    file.close();
	close(serial_port);

    ros::NodeHandle nh;

    

    //verify that callback was called by subscriber
    ASSERT_TRUE(true) << "callback was not called by subscriber";
}
*/


int main(int argc, char** argv) {
    ros::init(argc, argv, "TestInertialsenseNode");

    testing::InitGoogleTest(&argc, argv);

    std::thread t([]{ros::spin();}); // let ros spin in its own thread

    auto res = RUN_ALL_TESTS();

    ros::shutdown(); // this will cause the ros::spin() to return
    t.join();

    return res;
}
